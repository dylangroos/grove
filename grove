#!/usr/bin/env bash
#
# grove — worktree + tmux environment manager
#
# Branch name in, environment out. Creates a git worktree and tmux session
# for any branch — so you can work on multiple branches simultaneously.
#
# QUICK START:
#   grove feat/auth          # create worktree + tmux session
#   grove attach feat/auth   # attach to the session
#   grove ls                 # list worktrees + session status
#   grove rm feat/auth       # kill session + remove worktree
#
# CONFIGURATION (optional):
#   Create a Grovefile at your repo root:
#
#     GROVE_PROJECT="myapp"
#     grove_setup()   { npm install; }
#     grove_windows() { grove_window "server" "npm run dev"; }
#
# DEPENDENCIES:
#   - bash 4+   (macOS: brew install bash)
#   - git       (for worktree management)
#   - tmux      (for session management)
#

set -euo pipefail

GROVE_VERSION="0.2.0"

# ─── Colors ──────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ─── Globals ─────────────────────────────────────────────────────────────────

GROVE_ROOT=""
GROVE_PROJECT=""
GROVE_WORKTREE_DIR=".worktrees"

# Internal state for window collection
_GROVE_WINDOWS=()
_GROVE_WINDOW_CMDS=()

# ─── Helper functions (available to Grovefile) ───────────────────────────────

grove_window() {
    local name="$1"
    local cmd="$2"
    _GROVE_WINDOWS+=("$name")
    _GROVE_WINDOW_CMDS+=("$cmd")
}

# ─── Configuration ───────────────────────────────────────────────────────────

find_grove_root() {
    # Use git to find the true repo root (works from inside worktrees too)
    local toplevel gitcommon

    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
    gitcommon="$(git rev-parse --git-common-dir 2>/dev/null)" || return 1

    # git-common-dir gives us the path to the shared .git directory.
    # For worktrees this points back to the main repo's .git, so resolve it.
    if [[ "$gitcommon" == "$toplevel/.git" ]]; then
        GROVE_ROOT="$toplevel"
    else
        # We're inside a worktree — resolve the main repo root
        GROVE_ROOT="$(cd "$toplevel" && cd "$(git rev-parse --git-common-dir)/.." && pwd)"
    fi
}

load_grovefile() {
    if ! find_grove_root; then
        echo -e "${RED}Error:${NC} Not in a git repository" >&2
        exit 1
    fi

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        # shellcheck disable=SC1091
        source "$GROVE_ROOT/Grovefile"
    fi

    # Default project name to repo dirname if not set
    if [[ -z "${GROVE_PROJECT:-}" ]]; then
        GROVE_PROJECT="$(basename "$GROVE_ROOT")"
    fi
}

# ─── Naming ──────────────────────────────────────────────────────────────────

slugify_branch() {
    echo "$1" \
        | sed 's/\//-/g; s/[^a-zA-Z0-9_-]/-/g' \
        | sed 's/--*/-/g; s/^-//; s/-$//' \
        | cut -c1-50
}

session_name() {
    local slug="$1"
    echo "grove-${GROVE_PROJECT}-${slug}"
}

# ─── Commands ────────────────────────────────────────────────────────────────

cmd_open() {
    local branch="$1"
    shift
    local do_attach=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --attach|-a) do_attach=true ;;
            *) echo -e "${RED}Error:${NC} Unknown option: $1" >&2; exit 1 ;;
        esac
        shift
    done

    local slug session wt_dir
    slug="$(slugify_branch "$branch")"
    session="$(session_name "$slug")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    # ── Create worktree if needed ──
    if [[ ! -d "$wt_dir" ]]; then
        mkdir -p "$GROVE_ROOT/$GROVE_WORKTREE_DIR"

        echo -e "${BOLD}Creating worktree:${NC} $branch"

        local git_output
        if git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add "$wt_dir" "$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        elif git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add --track -b "$branch" "$wt_dir" "origin/$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        else
            echo -e "  ${DIM}Branch '$branch' not found, creating from current HEAD${NC}"
            git_output=$(git -C "$GROVE_ROOT" worktree add -b "$branch" "$wt_dir" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        fi

        # Copy .env if it exists in the main repo
        if [[ -f "$GROVE_ROOT/.env" ]]; then
            cp "$GROVE_ROOT/.env" "$wt_dir/.env"
            echo -e "  ${DIM}Copied .env${NC}"
        fi

        # Run setup hook
        if declare -f grove_setup >/dev/null 2>&1; then
            echo -e "\n${BOLD}Running setup...${NC}"
            if ! (cd "$wt_dir" && grove_setup); then
                echo -e "${YELLOW}Warning:${NC} grove_setup failed (worktree still created)"
            fi
        fi

        echo -e "${GREEN}✓${NC} Worktree created: $wt_dir"
    fi

    # ── Create tmux session if needed ──
    if ! tmux has-session -t "$session" 2>/dev/null; then
        _GROVE_WINDOWS=()
        _GROVE_WINDOW_CMDS=()

        if declare -f grove_windows >/dev/null 2>&1; then
            grove_windows
        fi

        if [[ ${#_GROVE_WINDOWS[@]} -gt 0 ]]; then
            # Create session with the first window
            tmux new-session -d -s "$session" -n "${_GROVE_WINDOWS[0]}" -c "$wt_dir"
            tmux send-keys -t "$session:${_GROVE_WINDOWS[0]}" "${_GROVE_WINDOW_CMDS[0]}" C-m

            # Create remaining windows
            for i in $(seq 1 $((${#_GROVE_WINDOWS[@]} - 1))); do
                tmux new-window -t "$session" -n "${_GROVE_WINDOWS[$i]}" -c "$wt_dir"
                tmux send-keys -t "$session:${_GROVE_WINDOWS[$i]}" "${_GROVE_WINDOW_CMDS[$i]}" C-m
            done

            # Always add a shell window
            tmux new-window -t "$session" -n "shell" -c "$wt_dir"
        else
            # No windows defined — just a shell
            tmux new-session -d -s "$session" -n "shell" -c "$wt_dir"
        fi

        echo -e "${GREEN}✓${NC} Session started: $session"
    else
        echo -e "Session already running: $session"
    fi

    echo -e "  Attach: ${DIM}grove attach $branch${NC}"

    if $do_attach; then
        exec tmux attach-session -t "$session"
    fi
}

cmd_attach() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: grove attach <branch>" >&2
        exit 1
    fi

    local slug session
    slug="$(slugify_branch "$branch")"
    session="$(session_name "$slug")"

    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo -e "${RED}Error:${NC} No session for '$branch'" >&2
        echo -e "Start it first: ${DIM}grove $branch${NC}" >&2
        exit 1
    fi

    exec tmux attach-session -t "$session"
}

cmd_ls() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo -e "${DIM}No worktrees${NC}"
        return 0
    fi

    printf "${DIM}%-30s %-12s${NC}\n" "BRANCH" "SESSION"

    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue

        local slug branch session status
        slug="$(basename "$wt_dir")"
        branch="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$slug")"
        session="$(session_name "$slug")"

        if tmux has-session -t "$session" 2>/dev/null; then
            # Check if any client is attached
            local clients
            clients="$(tmux list-clients -t "$session" 2>/dev/null | wc -l | tr -d ' ')"
            if [[ "$clients" -gt 0 ]]; then
                status="${GREEN}attached${NC}"
            else
                status="${YELLOW}detached${NC}"
            fi
        else
            status="${DIM}-${NC}"
        fi

        printf "%-30s " "$branch"
        echo -e "$status"
    done
}

cmd_rm() {
    local branch="${1:-}"

    # Handle --all flag
    if [[ "$branch" == "--all" ]]; then
        cmd_rm_all
        return
    fi

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: grove rm <branch>" >&2
        echo "       grove rm --all" >&2
        exit 1
    fi

    local slug session wt_dir
    slug="$(slugify_branch "$branch")"
    session="$(session_name "$slug")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} Worktree not found: $slug" >&2
        exit 1
    fi

    # Safety: refuse if cwd is inside the worktree
    local real_pwd real_wt
    real_pwd="$(cd "$PWD" && pwd -P)"
    real_wt="$(cd "$wt_dir" && pwd -P 2>/dev/null || echo "$wt_dir")"
    if [[ "$real_pwd" == "$real_wt"* ]]; then
        echo -e "${RED}Error:${NC} Cannot remove worktree while inside it" >&2
        echo -e "  cd out first: ${DIM}cd $GROVE_ROOT${NC}" >&2
        exit 1
    fi

    # Kill tmux session if running
    if tmux has-session -t "$session" 2>/dev/null; then
        tmux kill-session -t "$session"
        echo -e "Session killed: $session"
    fi

    # Remove worktree
    git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true
    echo -e "${GREEN}✓${NC} Removed: $slug"
}

cmd_rm_all() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo "Nothing to remove."
        return 0
    fi

    # List what will be removed
    echo -e "${BOLD}Will remove:${NC}"
    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        echo "  $(basename "$wt_dir")"
    done

    echo
    read -rp "Remove all worktrees and sessions? [y/N] " confirm
    if [[ "$confirm" != [yY] ]]; then
        echo "Cancelled."
        return 0
    fi

    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        local slug session
        slug="$(basename "$wt_dir")"
        session="$(session_name "$slug")"

        if tmux has-session -t "$session" 2>/dev/null; then
            tmux kill-session -t "$session"
        fi

        git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    done

    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true
    echo -e "${GREEN}✓${NC} All worktrees removed"
}

# ─── Init ───────────────────────────────────────────────────────────────────

detect_project() {
    local dir="$1"
    local type="unknown" setup="" window="" pm="npm"

    # Detect Node.js package manager from lock files
    if [[ -f "$dir/bun.lockb" ]] || [[ -f "$dir/bun.lock" ]]; then
        pm="bun"
    elif [[ -f "$dir/pnpm-lock.yaml" ]]; then
        pm="pnpm"
    elif [[ -f "$dir/yarn.lock" ]]; then
        pm="yarn"
    fi

    if [[ -f "$dir/Cargo.toml" ]]; then
        type="rust"
        setup="cargo build"
        window="cargo run"
    elif [[ -f "$dir/go.mod" ]]; then
        type="go"
        setup="go build ./..."
        window="go run ."
    elif [[ -f "$dir/package.json" ]]; then
        type="node ($pm)"
        setup="$pm install"
        # Check if "dev" script exists in package.json
        if grep -q '"dev"' "$dir/package.json" 2>/dev/null; then
            window="$pm run dev"
        elif grep -q '"start"' "$dir/package.json" 2>/dev/null; then
            window="$pm start"
        fi
    elif [[ -f "$dir/pyproject.toml" ]]; then
        if [[ -f "$dir/uv.lock" ]]; then
            type="python (uv)"
            setup="uv sync"
        else
            type="python"
            setup="pip install -e ."
        fi
    elif [[ -f "$dir/requirements.txt" ]]; then
        type="python"
        setup="pip install -r requirements.txt"
    elif [[ -f "$dir/Gemfile" ]]; then
        type="ruby"
        setup="bundle install"
        if [[ -f "$dir/bin/rails" ]]; then
            window="bin/rails server"
        fi
    elif [[ -f "$dir/composer.json" ]]; then
        type="php"
        setup="composer install"
        if [[ -f "$dir/artisan" ]]; then
            window="php artisan serve"
        fi
    fi

    echo "$type"
    echo "$setup"
    echo "$window"
}

window_name_from_cmd() {
    local cmd="$1" index="$2"

    # cd <dir> && ... → use <dir>
    if [[ "$cmd" =~ ^cd[[:space:]]+([^[:space:]&]+)[[:space:]]*\&\& ]]; then
        echo "${BASH_REMATCH[1]}"
        return
    fi

    # * run <name> → use <name>
    if [[ "$cmd" =~ [[:space:]]run[[:space:]]+([^[:space:]]+) ]]; then
        echo "${BASH_REMATCH[1]}"
        return
    fi

    # * start → "start"
    if [[ "$cmd" =~ [[:space:]]start$ ]] || [[ "$cmd" =~ ^[^[:space:]]+[[:space:]]start$ ]]; then
        echo "start"
        return
    fi

    echo "window-$index"
}

cmd_init() {
    if ! find_grove_root; then
        echo -e "${RED}Error:${NC} Not in a git repository" >&2
        exit 1
    fi

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        echo -e "${RED}Error:${NC} Grovefile already exists" >&2
        exit 1
    fi

    local project_name
    project_name="$(basename "$GROVE_ROOT")"

    # Detect project type
    local detection type default_setup default_window
    detection="$(detect_project "$GROVE_ROOT")"
    type="$(echo "$detection" | sed -n '1p')"
    default_setup="$(echo "$detection" | sed -n '2p')"
    default_window="$(echo "$detection" | sed -n '3p')"

    if [[ "$type" != "unknown" ]]; then
        echo -e "Detected: ${BOLD}${type}${NC}"
    fi
    echo

    # ── Collect setup commands ──
    local setup_cmds=()
    local first=true

    echo -e "${BOLD}Setup${NC} (runs once per worktree, empty line to skip):"

    while true; do
        if $first; then
            printf "  [%s] > " "$default_setup"
            first=false
            local line
            IFS= read -r line || break
            if [[ -z "$line" ]]; then
                # Accept default
                if [[ -n "$default_setup" ]]; then
                    setup_cmds+=("$default_setup")
                fi
                break
            else
                setup_cmds+=("$line")
            fi
        else
            printf "  > "
            local line
            IFS= read -r line || break
            if [[ -z "$line" ]]; then
                break
            fi
            setup_cmds+=("$line")
        fi
    done

    echo

    # ── Collect window commands ──
    local window_cmds=()
    first=true

    echo -e "${BOLD}Windows${NC} (each gets a tmux window, empty line to skip):"

    while true; do
        if $first; then
            printf "  [%s] > " "$default_window"
            first=false
            local line
            IFS= read -r line || break
            if [[ -z "$line" ]]; then
                if [[ -n "$default_window" ]]; then
                    window_cmds+=("$default_window")
                fi
                break
            else
                window_cmds+=("$line")
            fi
        else
            printf "  > "
            local line
            IFS= read -r line || break
            if [[ -z "$line" ]]; then
                break
            fi
            window_cmds+=("$line")
        fi
    done

    echo

    # ── Generate Grovefile ──
    local grovefile=""
    grovefile+="GROVE_PROJECT=\"${project_name}\""
    grovefile+=$'\n'

    if [[ ${#setup_cmds[@]} -gt 0 ]]; then
        grovefile+=$'\n'
        grovefile+="grove_setup() {"
        grovefile+=$'\n'
        for cmd in "${setup_cmds[@]}"; do
            grovefile+="    ${cmd}"
            grovefile+=$'\n'
        done
        grovefile+="}"
        grovefile+=$'\n'
    fi

    if [[ ${#window_cmds[@]} -gt 0 ]]; then
        grovefile+=$'\n'
        grovefile+="grove_windows() {"
        grovefile+=$'\n'
        local i=1
        for cmd in "${window_cmds[@]}"; do
            local wname
            wname="$(window_name_from_cmd "$cmd" "$i")"
            grovefile+="    grove_window \"${wname}\" \"${cmd}\""
            grovefile+=$'\n'
            i=$((i + 1))
        done
        grovefile+="}"
        grovefile+=$'\n'
    fi

    printf '%s' "$grovefile" > "$GROVE_ROOT/Grovefile"

    echo -e "${GREEN}✓${NC} Created Grovefile"
    echo
    # Display the generated Grovefile indented
    while IFS= read -r line; do
        echo "  $line"
    done < "$GROVE_ROOT/Grovefile"
}

cmd_completions() {
    cat <<'COMP'
# grove shell completions — add to .bashrc or .zshrc:
#   eval "$(grove completions)"

_grove_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case "$prev" in
        attach|rm)
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                COMPREPLY=($(compgen -W "$(ls "$wt_base" 2>/dev/null)" -- "$cur"))
            fi
            ;;
        grove)
            local subcmds="ls rm attach init help version completions"
            local branches=""
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                branches="$(ls "$wt_base" 2>/dev/null)"
            fi
            local git_branches
            git_branches="$(git branch --format='%(refname:short)' 2>/dev/null)"
            COMPREPLY=($(compgen -W "$subcmds $branches $git_branches" -- "$cur"))
            ;;
    esac
}

if [[ -n "$ZSH_VERSION" ]]; then
    autoload -U +X bashcompinit && bashcompinit
fi
complete -F _grove_completions grove
COMP
}

cmd_help() {
    cat <<EOF
$(echo -e "${BOLD}grove${NC}") — worktree + tmux environment manager (v${GROVE_VERSION})

$(echo -e "${BOLD}USAGE:${NC}")
  grove <branch>               Create worktree + tmux session (idempotent)
  grove <branch> --attach      Create and attach to session
  grove attach <branch>        Attach to existing session
  grove ls                     List worktrees + session status
  grove rm <branch>            Kill session + remove worktree
  grove rm --all               Remove everything (with confirmation)

$(echo -e "${BOLD}OTHER:${NC}")
  grove init                   Generate a Grovefile interactively
  grove help                   Show this help
  grove version                Show version
  grove completions            Output shell completions

$(echo -e "${BOLD}CONFIGURATION:${NC}")
  Create a Grovefile at your repo root (optional — grove works without one):

    GROVE_PROJECT="myapp"        # defaults to repo dirname
    grove_setup()   { npm install; }
    grove_windows() { grove_window "server" "npm run dev"; }
EOF
}

# ─── Main Dispatch ───────────────────────────────────────────────────────────

main() {
    local cmd="${1:-}"

    case "$cmd" in
        "")
            load_grovefile
            cmd_ls
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            echo "grove v${GROVE_VERSION}"
            ;;
        ls|list)
            load_grovefile
            cmd_ls
            ;;
        rm|remove)
            load_grovefile
            cmd_rm "${2:-}"
            ;;
        attach)
            load_grovefile
            cmd_attach "${2:-}"
            ;;
        completions)
            cmd_completions
            ;;
        init)
            cmd_init
            ;;
        *)
            load_grovefile
            cmd_open "$cmd" "${@:2}"
            ;;
    esac
}

main "$@"
