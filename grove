#!/usr/bin/env bash
#
# grove — agent-first worktree manager
#
# Spawn coding agents in git worktrees. Snap in, snap out, let them work.
#
# QUICK START:
#   gr checkout feat/auth "add auth"   # worktree + background agent
#   gr checkout feat/auth              # worktree + interactive agent
#   gr status                          # all worktrees, agents, activity
#   gr attach feat/auth                # snap into running agent
#   gr rm feat/auth                    # kill agent + remove worktree
#
# SHORTHANDS:
#   gr feat/auth "add auth"            # same as gr checkout feat/auth "add auth"
#   gr                                 # same as gr status
#
# CONFIGURATION:
#   ~/.grove           — global config (agent choice)
#   Grovefile          — per-repo (project name, setup hook)
#
# DEPENDENCIES:
#   - bash 4+   (macOS: brew install bash)
#   - git       (for worktree management)
#   - dtach     (for detachable agent sessions)
#

set -euo pipefail

GROVE_VERSION="0.3.0"

# ─── Colors ──────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ─── Globals ─────────────────────────────────────────────────────────────────

GROVE_ROOT=""
GROVE_PROJECT=""
GROVE_WORKTREE_DIR=".worktrees"
GROVE_CONFIG="$HOME/.grove"
GROVE_AGENT=""
GROVE_OS="linux"
[[ "$(uname -s)" == "Darwin" ]] && GROVE_OS="darwin"

# ─── Configuration ───────────────────────────────────────────────────────────

find_grove_root() {
    local toplevel gitcommon

    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
    gitcommon="$(git rev-parse --git-common-dir 2>/dev/null)" || return 1

    if [[ "$gitcommon" == "$toplevel/.git" ]]; then
        GROVE_ROOT="$toplevel"
    else
        GROVE_ROOT="$(cd "$toplevel" && cd "$(git rev-parse --git-common-dir)/.." && pwd)"
    fi
}

load_grove_config() {
    if [[ -f "$GROVE_CONFIG" ]]; then
        # shellcheck disable=SC1090
        source "$GROVE_CONFIG"
    fi
}

load_grovefile() {
    if ! find_grove_root; then
        echo -e "${RED}Error:${NC} Not in a git repository" >&2
        exit 1
    fi

    load_grove_config

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        # shellcheck disable=SC1091
        source "$GROVE_ROOT/Grovefile"
    fi

    if [[ -z "${GROVE_PROJECT:-}" ]]; then
        GROVE_PROJECT="$(basename "$GROVE_ROOT")"
    fi
}

# ─── Naming ──────────────────────────────────────────────────────────────────

slugify_branch() {
    echo "$1" \
        | sed 's/\//-/g; s/[^a-zA-Z0-9_-]/-/g' \
        | sed 's/--*/-/g; s/^-//; s/-$//' \
        | cut -c1-50
}

# ─── Agent helpers ───────────────────────────────────────────────────────────

detect_agent_name() {
    if command -v claude >/dev/null 2>&1; then
        echo "claude"
    elif command -v codex >/dev/null 2>&1; then
        echo "codex"
    elif command -v aider >/dev/null 2>&1; then
        echo "aider"
    fi
}

build_agent_cmd() {
    local agent="$1"
    local prompt="${2:-}"
    local continue_mode="${3:-}"

    if [[ -z "$agent" ]]; then
        return 1
    fi

    # Determine agent flags:
    #   - If GROVE_AGENT_FLAGS is set (even to ""), use that value
    #   - If unset, apply smart defaults (--dangerously-skip-permissions for claude)
    local flags=""
    if [[ -n "${GROVE_AGENT_FLAGS+x}" ]]; then
        flags="$GROVE_AGENT_FLAGS"
    else
        case "$agent" in
            claude) flags="--dangerously-skip-permissions" ;;
        esac
    fi

    local cmd="$agent"
    [[ -n "$flags" ]] && cmd="$cmd $flags"

    if [[ -n "$prompt" ]]; then
        case "$agent" in
            claude)
                [[ -n "$continue_mode" ]] && cmd="$cmd --continue"
                echo "$cmd \"$prompt\""
                ;;
            codex)  echo "codex \"$prompt\"" ;;
            aider)  echo "aider --message \"$prompt\"" ;;
            *)      echo "$agent \"$prompt\"" ;;
        esac
    else
        case "$agent" in
            claude)
                [[ -n "$continue_mode" ]] && cmd="$cmd --continue"
                echo "$cmd"
                ;;
            *)      echo "$agent" ;;
        esac
    fi
}

grove_socket_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-socket"
}

grove_log_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-agent.log"
}

grove_prompt_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-prompt"
}

is_agent_running() {
    local wt_dir="${1%/}"
    local socket
    socket="$(grove_socket_path "$wt_dir")"
    [[ -S "$socket" ]] || return 1
    # Verify dtach process is alive; clean up stale socket
    local pid=""
    if command -v fuser >/dev/null 2>&1; then
        pid="$(fuser "$socket" 2>/dev/null | tr -d '[:space:]')" || true
    fi
    if [[ -z "$pid" ]] && command -v lsof >/dev/null 2>&1; then
        pid="$(lsof -t "$socket" 2>/dev/null | head -1)" || true
    fi
    if [[ -n "$pid" ]]; then
        if ! kill -0 "$pid" 2>/dev/null; then
            rm -f "$socket"
            return 1
        fi
    fi
    # If neither fuser nor lsof found a PID, trust the socket exists
    return 0
}

file_mtime() {
    if [[ "$GROVE_OS" == "darwin" ]]; then
        stat -f %m "$1" 2>/dev/null
    else
        stat -c %Y "$1" 2>/dev/null
    fi
}

strip_ansi() {
    sed 's/\x1b\[[0-9;?]*[a-zA-Z]//g; s/\x1b\][^\x07]*\x07//g; s/\x1b(B//g' | tr -d '\r'
}

get_agent_status() {
    local wt_dir="${1%/}"
    if ! is_agent_running "$wt_dir"; then
        echo "done"; return 0
    fi
    local log_file
    log_file="$(grove_log_path "$wt_dir")"
    if [[ ! -f "$log_file" ]]; then
        echo "running"; return 0
    fi

    # Check last few lines for prompt patterns (permission prompts, confirmations)
    local tail_lines
    tail_lines="$(tail -5 "$log_file" 2>/dev/null | strip_ansi | LC_ALL=C tr -cd ' -~\\n')"
    if echo "$tail_lines" | grep -qiE '(Allow|Deny|yes.*no|\\[Y/n\\]|\\[y/N\\]|approve|reject|Continue\\?|Do you want)'; then
        echo "waiting"
        return 0
    fi

    # Fall back to time-based detection
    local now log_mtime age
    now="$(date +%s)"
    log_mtime="$(file_mtime "$log_file")" || log_mtime=0
    age=$((now - log_mtime))

    if [[ "$age" -le 10 ]]; then
        echo "running"
    elif [[ "$age" -le 120 ]]; then
        echo "thinking"
    else
        echo "idle"
    fi
}

has_prior_session() {
    local wt_dir="${1%/}"
    local log_file
    log_file="$(grove_log_path "$wt_dir")"
    [[ -s "$log_file" ]]
}

kill_agent() {
    local wt_dir="$1"
    local socket
    socket="$(grove_socket_path "$wt_dir")"

    if [[ -S "$socket" ]]; then
        # Get the PID of the dtach process from the socket
        local pid=""
        if command -v fuser >/dev/null 2>&1; then
            pid="$(fuser "$socket" 2>/dev/null | tr -d '[:space:]')" || true
        fi
        if [[ -z "$pid" ]] && command -v lsof >/dev/null 2>&1; then
            pid="$(lsof -t "$socket" 2>/dev/null | head -1)" || true
        fi

        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            # Wait briefly for cleanup
            local i=0
            while kill -0 "$pid" 2>/dev/null && [[ $i -lt 10 ]]; do
                sleep 0.1
                i=$((i + 1))
            done
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi

        rm -f "$socket"
    fi
}

launch_agent() {
    local mode="$1" socket="$2" wt_dir="$3" agent_cmd="$4" log_file="$5"
    local script_part
    if [[ "$GROVE_OS" == "darwin" ]]; then
        script_part="script -qa '$log_file' bash -c '$agent_cmd'"
    else
        script_part="script -aqfc '$agent_cmd' '$log_file'"
    fi
    if [[ "$mode" == "foreground" ]]; then
        dtach -c "$socket" -z bash -c "cd \"$wt_dir\" && $script_part"
    else
        dtach -n "$socket" -z bash -c "cd \"$wt_dir\" && $script_part"
    fi
}

# ─── Formatting helpers ─────────────────────────────────────────────────────

format_duration() {
    local seconds="$1"

    if [[ "$seconds" -lt 60 ]]; then
        echo "${seconds}s ago"
    elif [[ "$seconds" -lt 3600 ]]; then
        echo "$((seconds / 60))m ago"
    elif [[ "$seconds" -lt 86400 ]]; then
        echo "$((seconds / 3600))h ago"
    else
        echo "$((seconds / 86400))d ago"
    fi
}

get_last_activity() {
    local wt_dir="$1"
    local base_file="$wt_dir/.grove-base-commit"

    # If base commit recorded, skip if no agent commits yet
    if [[ -f "$base_file" ]]; then
        local base head
        base="$(cat "$base_file")"
        head="$(cd "$wt_dir" && git rev-parse HEAD 2>/dev/null)" || return 1
        [[ "$head" != "$base" ]] || return 1
    fi

    local timestamp subject
    timestamp="$(cd "$wt_dir" && git log -1 --format='%ct' 2>/dev/null)" || return 1
    subject="$(cd "$wt_dir" && git log -1 --format='%s' 2>/dev/null)" || return 1
    [[ -n "$timestamp" ]] || return 1

    local now elapsed duration
    now="$(date +%s)"
    elapsed=$((now - timestamp))
    duration="$(format_duration "$elapsed")"

    echo "${duration} · \"${subject}\""
}

get_log_activity() {
    local wt_dir="${1%/}"
    local log_file
    log_file="$(grove_log_path "$wt_dir")"
    [[ -s "$log_file" ]] || return 1

    local line
    line="$(tail -20 "$log_file" \
        | sed 's/\x1b\[[0-9;?]*[a-zA-Z]//g' \
        | sed 's/\x1b\][^\x07]*\x07//g' \
        | sed 's/\]0;[^]]*//g' \
        | tr -d '\r' \
        | LC_ALL=C tr -cd ' -~\n' \
        | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
        | grep '[a-zA-Z]' \
        | tail -1)"
    [[ -n "$line" ]] || return 1

    # Truncate to 60 chars for status display
    if [[ ${#line} -gt 60 ]]; then
        line="${line:0:57}..."
    fi
    echo "$line"
}

get_diff_stat() {
    local wt_dir="$1"
    local base

    base="$(cd "$wt_dir" && git merge-base HEAD "$(git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null || echo main)" 2>/dev/null)" || return 1

    local stat
    stat="$(cd "$wt_dir" && git diff --shortstat "$base"..HEAD 2>/dev/null)" || return 1

    if [[ -z "$stat" ]]; then
        return 1
    fi

    # Parse "3 files changed, 42 insertions(+), 8 deletions(-)"
    local files ins del
    files="$(echo "$stat" | grep -oE '[0-9]+ file' | grep -oE '[0-9]+')" || files="0"
    ins="$(echo "$stat" | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+')" || ins="0"
    del="$(echo "$stat" | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+')" || del="0"

    echo "+${ins} -${del} (${files} files)"
}

# ─── Commands ────────────────────────────────────────────────────────────────

cmd_checkout() {
    local branch="$1"
    shift
    local prompt="${*:-}"

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    # If no prompt given and we have a TTY, ask interactively
    if [[ -z "$prompt" && -t 0 ]]; then
        printf "${DIM}Prompt (enter to attach interactively):${NC} "
        IFS= read -r prompt
    fi

    # ── Create worktree if needed ──
    if [[ ! -d "$wt_dir" ]]; then
        mkdir -p "$GROVE_ROOT/$GROVE_WORKTREE_DIR"

        echo -e "${BOLD}Creating worktree:${NC} $branch"

        local git_output
        if git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add "$wt_dir" "$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        elif git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add --track -b "$branch" "$wt_dir" "origin/$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        else
            echo -e "  ${DIM}Branch '$branch' not found, creating from current HEAD${NC}"
            git_output=$(git -C "$GROVE_ROOT" worktree add -b "$branch" "$wt_dir" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        fi

        # Copy .env if it exists in the main repo
        if [[ -f "$GROVE_ROOT/.env" ]]; then
            cp "$GROVE_ROOT/.env" "$wt_dir/.env"
            echo -e "  ${DIM}Copied .env${NC}"
        fi

        # Run setup hook
        if declare -f setup >/dev/null 2>&1; then
            echo -e "\n${BOLD}Running setup...${NC}"
            if ! (cd "$wt_dir" && setup); then
                echo -e "${YELLOW}Warning:${NC} setup failed (worktree still created)"
            fi
        fi

        # Record base commit so status can distinguish inherited vs agent commits
        git -C "$wt_dir" rev-parse HEAD > "$wt_dir/.grove-base-commit"

        echo -e "${GREEN}✓${NC} Worktree created: $wt_dir"
    fi

    # ── Start agent ──
    local agent="${GROVE_AGENT:-}"
    if [[ -z "$agent" ]]; then
        agent="$(detect_agent_name)"
    fi

    if [[ -z "$agent" ]]; then
        echo -e "${DIM}No agent configured. Run 'gr init' or set GROVE_AGENT in ~/.grove${NC}"
        return 0
    fi

    local socket log_file
    socket="$(grove_socket_path "$wt_dir")"
    log_file="$(grove_log_path "$wt_dir")"

    # Save prompt if provided
    if [[ -n "$prompt" ]]; then
        echo "$prompt" > "$(grove_prompt_path "$wt_dir")"
    fi

    local agent_status
    agent_status="$(get_agent_status "$wt_dir")"

    # ── Agent already running ──
    if [[ "$agent_status" != "done" ]]; then
        if [[ -z "$prompt" ]]; then
            # No prompt → auto-attach
            if [[ -t 0 ]]; then
                echo -e "Attaching to agent in ${BOLD}$branch${NC}"
                echo -e "  ${DIM}Detach with Ctrl+\\${NC}"
                exec dtach -a "$socket" -z -r ctrl_l
            else
                echo -e "Agent running in ${BOLD}$branch${NC}"
                echo -e "  Attach: ${DIM}gr attach $branch${NC}"
                return 0
            fi
        elif [[ "$agent_status" == "waiting" ]]; then
            # Idle agent + new prompt → kill and restart with --continue
            kill_agent "$wt_dir"
            local agent_cmd
            agent_cmd="$(build_agent_cmd "$agent" "$prompt" "continue")"
            launch_agent background "$socket" "$wt_dir" "$agent_cmd" "$log_file"
            echo -e "${GREEN}✓${NC} Agent restarted with --continue (background): ${BOLD}$agent${NC}"
            echo -e "  Prompt: ${DIM}\"$prompt\"${NC}"
            echo -e "  Attach: ${DIM}gr attach $branch${NC}"
            return 0
        else
            # Agent actively working + new prompt → warn
            echo -e "${YELLOW}Agent is busy${NC} in ${BOLD}$branch${NC}"
            echo -e "  Attach: ${DIM}gr attach $branch${NC}"
            return 0
        fi
    fi

    # ── Agent not running — start fresh or continue ──
    local continue_flag=""
    if has_prior_session "$wt_dir"; then
        continue_flag="continue"
    fi

    local agent_cmd
    agent_cmd="$(build_agent_cmd "$agent" "$prompt" "$continue_flag")"

    if [[ -n "$prompt" ]]; then
        # Background mode: dtach -n (no attach)
        launch_agent background "$socket" "$wt_dir" "$agent_cmd" "$log_file"
        echo -e "${GREEN}✓${NC} Agent started (background): ${BOLD}$agent${NC}"
        echo -e "  Prompt: ${DIM}\"$prompt\"${NC}"
        echo -e "  Attach: ${DIM}gr attach $branch${NC}"
    elif [[ -t 0 ]]; then
        # Foreground mode: dtach -c (create and attach, needs TTY)
        echo -e "${GREEN}✓${NC} Starting agent: ${BOLD}$agent${NC}"
        echo -e "  ${DIM}Detach with Ctrl+\\${NC}"
        launch_agent foreground "$socket" "$wt_dir" "$agent_cmd" "$log_file"
    else
        # No TTY available — fall back to background
        launch_agent background "$socket" "$wt_dir" "$agent_cmd" "$log_file"
        echo -e "${GREEN}✓${NC} Agent started (background): ${BOLD}$agent${NC}"
        echo -e "  Attach: ${DIM}gr attach $branch${NC}"
    fi
}

cmd_status() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo -e "${DIM}No worktrees${NC}"
        return 0
    fi

    printf "${DIM}%-24s %-10s %-14s %s${NC}\n" "BRANCH" "AGENT" "STATUS" "ACTIVITY"

    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        cmd_status_single "$wt_dir"
    done
}

cmd_status_single() {
    local wt_dir="$1"
    local slug branch agent_name status_str activity diff_stat

    slug="$(basename "$wt_dir")"
    branch="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$slug")"

    # Agent name
    agent_name="${GROVE_AGENT:-}"
    if [[ -z "$agent_name" ]]; then
        agent_name="$(detect_agent_name)"
    fi
    agent_name="${agent_name:-—}"

    # Status with indicators
    local agent_status
    agent_status="$(get_agent_status "$wt_dir")"
    case "$agent_status" in
        running)  status_str="${GREEN}● running${NC}" ;;
        thinking) status_str="${YELLOW}◐ thinking${NC}" ;;
        waiting)  status_str="${RED}⚠ waiting${NC}" ;;
        idle)     status_str="${DIM}○ idle${NC}" ;;
        *)        status_str="${DIM}■ done${NC}" ;;
    esac

    # Diff stats
    diff_stat="$(get_diff_stat "$wt_dir" 2>/dev/null)" || diff_stat=""

    # Last activity
    activity="$(get_last_activity "$wt_dir" 2>/dev/null)" || activity=""

    if [[ -z "$activity" ]]; then
        activity="$(get_log_activity "$wt_dir" 2>/dev/null)" || activity=""
    fi

    # Prompt info fallback
    local prompt_file
    prompt_file="$(grove_prompt_path "$wt_dir")"
    if [[ -z "$activity" && -f "$prompt_file" ]]; then
        local saved_prompt
        saved_prompt="$(cat "$prompt_file")"
        activity="\"${saved_prompt}\""
    fi

    # Print row
    printf "%-24s %-10s " "$branch" "$agent_name"
    printf "%b" "$status_str"
    printf "%-4s" ""
    if [[ -n "$diff_stat" ]]; then
        printf " ${DIM}%s${NC}" "$diff_stat"
    fi
    if [[ -n "$activity" ]]; then
        echo -e "  $activity"
    else
        echo
    fi
}

cmd_attach() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr attach <branch>" >&2
        exit 1
    fi

    local slug wt_dir socket
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"
    socket="$(grove_socket_path "$wt_dir")"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        echo -e "Start it first: ${DIM}gr checkout $branch${NC}" >&2
        exit 1
    fi

    if [[ ! -S "$socket" ]]; then
        echo -e "${RED}Error:${NC} No running agent for '$branch'" >&2
        echo -e "Start one: ${DIM}gr checkout $branch${NC}" >&2
        exit 1
    fi

    exec dtach -a "$socket" -z -r ctrl_l
}

cmd_log() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr log <branch>" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    local base
    base="$(cd "$wt_dir" && git merge-base HEAD main 2>/dev/null)" || {
        # Fallback: just show recent commits
        (cd "$wt_dir" && git log --oneline -20)
        return
    }

    (cd "$wt_dir" && git log --oneline "$base"..HEAD)
}

cmd_diff() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr diff <branch>" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    local base
    base="$(cd "$wt_dir" && git merge-base HEAD main 2>/dev/null)" || {
        echo -e "${RED}Error:${NC} Could not find merge base with main" >&2
        exit 1
    }

    (cd "$wt_dir" && git diff "$base")
}

cmd_output() {
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr output <branch>" >&2
        exit 1
    fi

    local slug wt_dir log_file
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    log_file="$(grove_log_path "$wt_dir")"
    if [[ ! -s "$log_file" ]]; then
        echo -e "${DIM}No output yet${NC}"
        return 0
    fi

    cat "$log_file"
}

cmd_send() {
    local branch="${1:-}"
    local text="${2:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr send <branch> <text>" >&2
        exit 1
    fi

    if [[ -z "$text" ]]; then
        echo -e "${RED}Error:${NC} Missing text to send" >&2
        echo "Usage: gr send <branch> <text>" >&2
        exit 1
    fi

    local slug wt_dir socket
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"
    socket="$(grove_socket_path "$wt_dir")"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    if ! is_agent_running "$wt_dir"; then
        echo -e "${RED}Error:${NC} No running agent for '$branch'" >&2
        exit 1
    fi

    # Write to dtach socket using -p flag
    printf '%s\n' "$text" | dtach -p "$socket"
    echo -e "${GREEN}✓${NC} Sent to $branch"
}

cmd_approve() {
    local target="${1:-}"

    if [[ "$target" == "--all" ]]; then
        local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"
        local approved=0

        if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
            echo -e "${DIM}No worktrees${NC}"
            return 0
        fi

        for wt_dir in "$wt_base"/*/; do
            [[ -d "$wt_dir" ]] || continue
            local status
            status="$(get_agent_status "$wt_dir")"
            if [[ "$status" == "waiting" ]]; then
                local socket branch_name
                socket="$(grove_socket_path "$wt_dir")"
                branch_name="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null || basename "$wt_dir")"
                printf 'y\n' | dtach -p "$socket"
                echo -e "${GREEN}✓${NC} Approved: $branch_name"
                approved=$((approved + 1))
            fi
        done

        if [[ "$approved" -eq 0 ]]; then
            echo -e "${DIM}No agents waiting for approval${NC}"
        fi
        return 0
    fi

    if [[ -z "$target" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr approve <branch>" >&2
        echo "       gr approve --all" >&2
        exit 1
    fi

    # Single branch approve = send "y"
    cmd_send "$target" "y"
}

cmd_kill() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr kill <branch>" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    if ! is_agent_running "$wt_dir"; then
        echo -e "${DIM}No running agent for '$branch'${NC}"
        return 0
    fi

    kill_agent "$wt_dir"
    echo -e "${GREEN}✓${NC} Agent killed in $branch"
    echo -e "  ${DIM}Worktree kept at: $GROVE_WORKTREE_DIR/$slug${NC}"
    echo -e "  ${DIM}Review: gr diff $branch${NC}"
}

cmd_rm() {
    local branch="${1:-}"

    if [[ "$branch" == "--all" ]]; then
        cmd_rm_all
        return
    fi

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr rm <branch>" >&2
        echo "       gr rm --all" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} Worktree not found: $slug" >&2
        exit 1
    fi

    # Safety: refuse if cwd is inside the worktree
    local real_pwd real_wt
    real_pwd="$(cd "$PWD" && pwd -P)"
    real_wt="$(cd "$wt_dir" && pwd -P 2>/dev/null || echo "$wt_dir")"
    if [[ "$real_pwd" == "$real_wt"* ]]; then
        echo -e "${RED}Error:${NC} Cannot remove worktree while inside it" >&2
        echo -e "  cd out first: ${DIM}cd $GROVE_ROOT${NC}" >&2
        exit 1
    fi

    # Kill agent if running
    if is_agent_running "$wt_dir"; then
        kill_agent "$wt_dir"
        echo -e "Agent killed"
    fi

    # Remove worktree
    local wt_branch
    wt_branch="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null)" || true
    git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true

    # Clean up the branch if it's not checked out elsewhere
    if [[ -n "$wt_branch" && "$wt_branch" != "HEAD" ]]; then
        git -C "$GROVE_ROOT" branch -D "$wt_branch" 2>/dev/null || true
    fi

    echo -e "${GREEN}✓${NC} Removed: $slug"
}

cmd_rm_all() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo "Nothing to remove."
        return 0
    fi

    echo -e "${BOLD}Will remove:${NC}"
    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        echo "  $(basename "$wt_dir")"
    done

    echo
    read -rp "Remove all worktrees and agents? [y/N] " confirm
    if [[ "$confirm" != [yY] ]]; then
        echo "Cancelled."
        return 0
    fi

    local branches_to_delete=()
    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        local slug wt_branch
        slug="$(basename "$wt_dir")"
        wt_branch="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null)" || true
        if [[ -n "$wt_branch" && "$wt_branch" != "HEAD" ]]; then
            branches_to_delete+=("$wt_branch")
        fi

        kill_agent "$wt_dir"
        git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    done

    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true

    for br in "${branches_to_delete[@]}"; do
        git -C "$GROVE_ROOT" branch -D "$br" 2>/dev/null || true
    done

    echo -e "${GREEN}✓${NC} All worktrees removed"
}

# ─── Init ────────────────────────────────────────────────────────────────────

detect_project() {
    local dir="$1"
    local type="unknown" setup=""

    local pm="npm"
    if [[ -f "$dir/bun.lockb" ]] || [[ -f "$dir/bun.lock" ]]; then
        pm="bun"
    elif [[ -f "$dir/pnpm-lock.yaml" ]]; then
        pm="pnpm"
    elif [[ -f "$dir/yarn.lock" ]]; then
        pm="yarn"
    fi

    if [[ -f "$dir/Cargo.toml" ]]; then
        type="rust"
        setup="cargo build"
    elif [[ -f "$dir/go.mod" ]]; then
        type="go"
        setup="go build ./..."
    elif [[ -f "$dir/package.json" ]]; then
        type="node ($pm)"
        setup="$pm install"
    elif [[ -f "$dir/pyproject.toml" ]]; then
        if [[ -f "$dir/uv.lock" ]]; then
            type="python (uv)"
            setup="uv sync"
        else
            type="python"
            setup="pip install -e ."
        fi
    elif [[ -f "$dir/requirements.txt" ]]; then
        type="python"
        setup="pip install -r requirements.txt"
    elif [[ -f "$dir/Gemfile" ]]; then
        type="ruby"
        setup="bundle install"
    elif [[ -f "$dir/composer.json" ]]; then
        type="php"
        setup="composer install"
    fi

    echo "$type"
    echo "$setup"
}

cmd_init() {
    # ── Global config (~/.grove) ──
    load_grove_config

    # Defaults: current values > auto-detect > empty
    local current_agent="${GROVE_AGENT:-}"
    [[ -z "$current_agent" ]] && current_agent="$(detect_agent_name)"
    local current_flags="${GROVE_AGENT_FLAGS:-}"

    echo -e "${BOLD}Global config${NC} (~/.grove)"
    echo -e "${BOLD}Agent${NC} (coding agent to use):"
    printf "  [%s] > " "$current_agent"
    local agent_line
    if IFS= read -r agent_line; then
        [[ -z "$agent_line" ]] && agent_line="$current_agent"
    fi

    if [[ -n "$agent_line" ]]; then
        printf 'GROVE_AGENT="%s"\n' "$agent_line" > "$GROVE_CONFIG"

        # Prompt for agent flags (only for claude, which has smart defaults)
        if [[ "$agent_line" == "claude" ]]; then
            local flags_hint="$current_flags"
            [[ -z "$flags_hint" ]] && flags_hint="--dangerously-skip-permissions"
            echo -e "${BOLD}Agent flags${NC} (default for background agents):"
            printf "  [%s] > " "$flags_hint"
            local flags_line
            if IFS= read -r flags_line; then
                [[ -z "$flags_line" ]] && flags_line="$flags_hint"
            fi
            if [[ -n "$flags_line" && "$flags_line" != "--dangerously-skip-permissions" ]]; then
                echo "GROVE_AGENT_FLAGS=\"$flags_line\"" >> "$GROVE_CONFIG"
            else
                printf '# GROVE_AGENT_FLAGS="--dangerously-skip-permissions"  # override default agent flags\n' >> "$GROVE_CONFIG"
            fi
        else
            printf '# GROVE_AGENT_FLAGS=""  # override default agent flags\n' >> "$GROVE_CONFIG"
        fi

        echo -e "${GREEN}✓${NC} Saved ~/.grove"
        GROVE_AGENT="$agent_line"
    else
        echo -e "${DIM}Skipped (no agent found)${NC}"
    fi

    echo

    # ── Per-repo Grovefile ──
    if ! find_grove_root; then
        echo -e "${DIM}Not in a git repo — skipping Grovefile${NC}"
        return 0
    fi

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        echo -e "${DIM}Grovefile already exists${NC}"
        return 0
    fi

    local project_name
    project_name="$(basename "$GROVE_ROOT")"

    local detection type default_setup
    detection="$(detect_project "$GROVE_ROOT")"
    type="$(echo "$detection" | sed -n '1p')"
    default_setup="$(echo "$detection" | sed -n '2p')"

    if [[ "$type" != "unknown" ]]; then
        echo -e "Detected: ${BOLD}${type}${NC}"
    fi

    # ── Collect setup commands ──
    local setup_cmds=()
    echo -e "${BOLD}Setup${NC} (runs once per worktree, empty line to skip):"
    printf "  [%s] > " "$default_setup"
    local line
    if IFS= read -r line; then
        if [[ -z "$line" && -n "$default_setup" ]]; then
            setup_cmds+=("$default_setup")
        elif [[ -n "$line" ]]; then
            setup_cmds+=("$line")
        fi
    fi

    echo

    # ── Generate Grovefile ──
    local grovefile=""
    grovefile+="GROVE_PROJECT=\"${project_name}\""
    grovefile+=$'\n'

    if [[ ${#setup_cmds[@]} -gt 0 ]]; then
        grovefile+=$'\n'
        grovefile+="setup() {"
        grovefile+=$'\n'
        for cmd in "${setup_cmds[@]}"; do
            grovefile+="    ${cmd}"
            grovefile+=$'\n'
        done
        grovefile+="}"
        grovefile+=$'\n'
    fi

    printf '%s' "$grovefile" > "$GROVE_ROOT/Grovefile"

    echo -e "${GREEN}✓${NC} Created Grovefile"
    echo
    while IFS= read -r line; do
        echo "  $line"
    done < "$GROVE_ROOT/Grovefile"
}

cmd_completions() {
    cat <<'COMP'
# grove shell completions — add to .bashrc or .zshrc:
#   eval "$(grove completions)"   or   eval "$(gr completions)"

_grove_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case "$prev" in
        attach|rm|log|diff|output|checkout|co|send|approve|kill)
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                # Offer both slug names (easy to type) and branch names
                local names=""
                for d in "$wt_base"/*/; do
                    [ -d "$d" ] || continue
                    names="$names $(basename "$d")"
                    local b
                    b="$(cd "$d" && git rev-parse --abbrev-ref HEAD 2>/dev/null)" || continue
                    [[ "$b" != "$(basename "$d")" ]] && names="$names $b"
                done
                COMPREPLY=($(compgen -W "$names" -- "$cur"))
            fi
            ;;
        grove|gr)
            local subcmds="checkout status log diff output send approve kill rm attach init help version completions"
            local branches=""
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                branches="$(ls "$wt_base" 2>/dev/null)"
            fi
            local git_branches
            git_branches="$(git branch --format='%(refname:short)' 2>/dev/null)"
            COMPREPLY=($(compgen -W "$subcmds $branches $git_branches" -- "$cur"))
            ;;
    esac
}

if [[ -n "$ZSH_VERSION" ]]; then
    autoload -U +X bashcompinit && bashcompinit
fi
complete -F _grove_completions grove
complete -F _grove_completions gr
COMP
}

cmd_help() {
    cat <<EOF
$(echo -e "${BOLD}grove${NC}") — agent-first worktree manager (v${GROVE_VERSION})

$(echo -e "${BOLD}USAGE:${NC}")
  gr checkout <branch>             Create worktree + start agent
                                   (prompts for task, enter to skip)
  gr <branch> "prompt"            Shorthand — skip the prompt step
  gr status                       Show all worktrees, agents, activity
  gr attach <branch>              Snap into a running agent session
  gr log <branch>                 Agent's commits on this branch
  gr diff <branch>                What the agent changed vs base
  gr output <branch>              Show agent's terminal output
  gr send <branch> <text>          Send input to a running agent
  gr approve <branch>              Approve a waiting agent prompt
  gr approve --all                 Approve all waiting agents
  gr kill <branch>                 Stop agent, keep worktree for review
  gr rm <branch>                  Kill agent + remove worktree
  gr rm --all                     Remove everything (with confirmation)

$(echo -e "${BOLD}OTHER:${NC}")
  gr init                         Set up ~/.grove + Grovefile
  gr help                         Show this help
  gr version                      Show version
  gr completions                  Output shell completions

$(echo -e "${BOLD}CONFIGURATION:${NC}")
  ~/.grove (global):
    GROVE_AGENT="claude"
    GROVE_AGENT_FLAGS="..."       Override flags passed to agent
                                  (unset = smart defaults)

  Grovefile (per-repo, optional):
    GROVE_PROJECT="myapp"
    setup() { npm install; }

$(echo -e "${BOLD}DETACH:${NC}")
  Ctrl+\\  detach from a foreground agent session
EOF
}

# ─── Main Dispatch ───────────────────────────────────────────────────────────

main() {
    local cmd="${1:-}"

    case "$cmd" in
        "")
            load_grovefile
            cmd_status
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            echo "grove v${GROVE_VERSION}"
            ;;
        checkout|co)
            load_grovefile
            if [[ -z "${2:-}" ]]; then
                echo -e "${RED}Error:${NC} Missing branch name" >&2
                echo "Usage: gr checkout <branch> [\"prompt\"]" >&2
                exit 1
            fi
            cmd_checkout "${@:2}"
            ;;
        status|ls|list)
            load_grovefile
            cmd_status
            ;;
        attach)
            load_grovefile
            cmd_attach "${2:-}"
            ;;
        log)
            load_grovefile
            cmd_log "${2:-}"
            ;;
        diff)
            load_grovefile
            cmd_diff "${2:-}"
            ;;
        output)
            load_grovefile
            cmd_output "${2:-}"
            ;;
        rm|remove)
            load_grovefile
            cmd_rm "${2:-}"
            ;;
        send)
            load_grovefile
            cmd_send "${2:-}" "${*:3}"
            ;;
        approve)
            load_grovefile
            cmd_approve "${2:-}"
            ;;
        kill)
            load_grovefile
            cmd_kill "${2:-}"
            ;;
        completions)
            cmd_completions
            ;;
        init)
            cmd_init
            ;;
        *)
            # Catch-all: treat as branch name (shorthand for checkout)
            load_grovefile
            cmd_checkout "$cmd" "${@:2}"
            ;;
    esac
}

main "$@"
