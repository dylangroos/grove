#!/usr/bin/env bash
#
# grove — agent-first worktree manager
#
# Spawn coding agents in git worktrees. Snap in, snap out, let them work.
#
# QUICK START:
#   gr checkout feat/auth "add auth"   # worktree + background agent
#   gr checkout feat/auth              # worktree + interactive agent
#   gr status                          # all worktrees, agents, activity
#   gr attach feat/auth                # snap into running agent
#   gr rm feat/auth                    # kill agent + remove worktree
#
# SHORTHANDS:
#   gr feat/auth "add auth"            # same as gr checkout feat/auth "add auth"
#   gr                                 # same as gr status
#
# CONFIGURATION:
#   ~/.grove           — global config (agent choice)
#   Grovefile          — per-repo (project name, setup hook)
#
# DEPENDENCIES:
#   - bash 4+   (macOS: brew install bash)
#   - git       (for worktree management)
#   - dtach     (for detachable agent sessions)
#

set -euo pipefail

GROVE_VERSION="0.3.0"

# ─── Colors ──────────────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ─── Globals ─────────────────────────────────────────────────────────────────

GROVE_ROOT=""
GROVE_PROJECT=""
GROVE_WORKTREE_DIR=".worktrees"
GROVE_CONFIG="$HOME/.grove"
GROVE_AGENT=""

# ─── Configuration ───────────────────────────────────────────────────────────

find_grove_root() {
    local toplevel gitcommon

    toplevel="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
    gitcommon="$(git rev-parse --git-common-dir 2>/dev/null)" || return 1

    if [[ "$gitcommon" == "$toplevel/.git" ]]; then
        GROVE_ROOT="$toplevel"
    else
        GROVE_ROOT="$(cd "$toplevel" && cd "$(git rev-parse --git-common-dir)/.." && pwd)"
    fi
}

load_grove_config() {
    if [[ -f "$GROVE_CONFIG" ]]; then
        # shellcheck disable=SC1090
        source "$GROVE_CONFIG"
    fi
}

load_grovefile() {
    if ! find_grove_root; then
        echo -e "${RED}Error:${NC} Not in a git repository" >&2
        exit 1
    fi

    load_grove_config

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        # shellcheck disable=SC1091
        source "$GROVE_ROOT/Grovefile"
    fi

    if [[ -z "${GROVE_PROJECT:-}" ]]; then
        GROVE_PROJECT="$(basename "$GROVE_ROOT")"
    fi
}

# ─── Naming ──────────────────────────────────────────────────────────────────

slugify_branch() {
    echo "$1" \
        | sed 's/\//-/g; s/[^a-zA-Z0-9_-]/-/g' \
        | sed 's/--*/-/g; s/^-//; s/-$//' \
        | cut -c1-50
}

# ─── Agent helpers ───────────────────────────────────────────────────────────

detect_agent_name() {
    if command -v claude >/dev/null 2>&1; then
        echo "claude"
    elif command -v codex >/dev/null 2>&1; then
        echo "codex"
    elif command -v aider >/dev/null 2>&1; then
        echo "aider"
    fi
}

build_agent_cmd() {
    local agent="$1"
    local prompt="${2:-}"

    if [[ -z "$agent" ]]; then
        return 1
    fi

    if [[ -n "$prompt" ]]; then
        case "$agent" in
            claude) echo "claude --dangerously-skip-permissions \"$prompt\"" ;;
            codex)  echo "codex \"$prompt\"" ;;
            aider)  echo "aider --message \"$prompt\"" ;;
            *)      echo "$agent \"$prompt\"" ;;
        esac
    else
        case "$agent" in
            claude) echo "claude --dangerously-skip-permissions" ;;
            *)      echo "$agent" ;;
        esac
    fi
}

grove_socket_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-socket"
}

grove_log_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-agent.log"
}

grove_prompt_path() {
    local wt_dir="$1"
    echo "$wt_dir/.grove-prompt"
}

is_agent_running() {
    local wt_dir="$1"
    local socket
    socket="$(grove_socket_path "$wt_dir")"
    [[ -S "$socket" ]]
}

kill_agent() {
    local wt_dir="$1"
    local socket
    socket="$(grove_socket_path "$wt_dir")"

    if [[ -S "$socket" ]]; then
        # Get the PID of the dtach process from the socket
        local pid
        pid="$(lsof -t "$socket" 2>/dev/null | head -1)" || true

        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            # Wait briefly for cleanup
            local i=0
            while kill -0 "$pid" 2>/dev/null && [[ $i -lt 10 ]]; do
                sleep 0.1
                i=$((i + 1))
            done
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi

        rm -f "$socket"
    fi
}

# ─── Formatting helpers ─────────────────────────────────────────────────────

format_duration() {
    local seconds="$1"

    if [[ "$seconds" -lt 60 ]]; then
        echo "${seconds}s ago"
    elif [[ "$seconds" -lt 3600 ]]; then
        echo "$((seconds / 60))m ago"
    elif [[ "$seconds" -lt 86400 ]]; then
        echo "$((seconds / 3600))h ago"
    else
        echo "$((seconds / 86400))d ago"
    fi
}

get_last_activity() {
    local wt_dir="$1"
    local timestamp subject

    timestamp="$(cd "$wt_dir" && git log -1 --format='%ct' 2>/dev/null)" || return 1
    subject="$(cd "$wt_dir" && git log -1 --format='%s' 2>/dev/null)" || return 1

    if [[ -z "$timestamp" ]]; then
        return 1
    fi

    local now elapsed duration
    now="$(date +%s)"
    elapsed=$((now - timestamp))
    duration="$(format_duration "$elapsed")"

    echo "${duration} · \"${subject}\""
}

get_diff_stat() {
    local wt_dir="$1"
    local base

    base="$(cd "$wt_dir" && git merge-base HEAD "$(git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null || echo main)" 2>/dev/null)" || return 1

    local stat
    stat="$(cd "$wt_dir" && git diff --shortstat "$base"..HEAD 2>/dev/null)" || return 1

    if [[ -z "$stat" ]]; then
        return 1
    fi

    # Parse "3 files changed, 42 insertions(+), 8 deletions(-)"
    local files ins del
    files="$(echo "$stat" | grep -oP '\d+ file' | grep -oP '\d+')" || files="0"
    ins="$(echo "$stat" | grep -oP '\d+ insertion' | grep -oP '\d+')" || ins="0"
    del="$(echo "$stat" | grep -oP '\d+ deletion' | grep -oP '\d+')" || del="0"

    echo "+${ins} -${del} (${files} files)"
}

# ─── Commands ────────────────────────────────────────────────────────────────

cmd_checkout() {
    local branch="$1"
    shift
    local prompt="${*:-}"

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    # If no prompt given and we have a TTY, ask interactively
    if [[ -z "$prompt" && -t 0 ]]; then
        printf "${DIM}Prompt (enter to attach interactively):${NC} "
        IFS= read -r prompt
    fi

    # ── Create worktree if needed ──
    if [[ ! -d "$wt_dir" ]]; then
        mkdir -p "$GROVE_ROOT/$GROVE_WORKTREE_DIR"

        echo -e "${BOLD}Creating worktree:${NC} $branch"

        local git_output
        if git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add "$wt_dir" "$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        elif git -C "$GROVE_ROOT" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            git_output=$(git -C "$GROVE_ROOT" worktree add --track -b "$branch" "$wt_dir" "origin/$branch" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        else
            echo -e "  ${DIM}Branch '$branch' not found, creating from current HEAD${NC}"
            git_output=$(git -C "$GROVE_ROOT" worktree add -b "$branch" "$wt_dir" 2>&1) || {
                echo -e "${RED}Error:${NC} Failed to create worktree for '$branch'" >&2
                echo -e "  ${DIM}${git_output}${NC}" >&2
                exit 1
            }
        fi

        # Copy .env if it exists in the main repo
        if [[ -f "$GROVE_ROOT/.env" ]]; then
            cp "$GROVE_ROOT/.env" "$wt_dir/.env"
            echo -e "  ${DIM}Copied .env${NC}"
        fi

        # Run setup hook
        if declare -f grove_setup >/dev/null 2>&1; then
            echo -e "\n${BOLD}Running setup...${NC}"
            if ! (cd "$wt_dir" && grove_setup); then
                echo -e "${YELLOW}Warning:${NC} grove_setup failed (worktree still created)"
            fi
        fi

        echo -e "${GREEN}✓${NC} Worktree created: $wt_dir"
    fi

    # ── Start agent ──
    local agent="${GROVE_AGENT:-}"
    if [[ -z "$agent" ]]; then
        agent="$(detect_agent_name)"
    fi

    if [[ -z "$agent" ]]; then
        echo -e "${DIM}No agent configured. Run 'gr init' or set GROVE_AGENT in ~/.grove${NC}"
        return 0
    fi

    # Check if agent is already running
    if is_agent_running "$wt_dir"; then
        echo -e "Agent already running in ${BOLD}$branch${NC}"
        echo -e "  Attach: ${DIM}gr attach $branch${NC}"
        return 0
    fi

    local socket log_file
    socket="$(grove_socket_path "$wt_dir")"
    log_file="$(grove_log_path "$wt_dir")"

    # Save prompt if provided
    if [[ -n "$prompt" ]]; then
        echo "$prompt" > "$(grove_prompt_path "$wt_dir")"
    fi

    local agent_cmd
    agent_cmd="$(build_agent_cmd "$agent" "$prompt")"

    if [[ -n "$prompt" ]]; then
        # Background mode: dtach -n (no attach)
        dtach -n "$socket" -z bash -c "cd \"$wt_dir\" && $agent_cmd" > "$log_file" 2>&1
        echo -e "${GREEN}✓${NC} Agent started (background): ${BOLD}$agent${NC}"
        echo -e "  Prompt: ${DIM}\"$prompt\"${NC}"
        echo -e "  Attach: ${DIM}gr attach $branch${NC}"
    elif [[ -t 0 ]]; then
        # Foreground mode: dtach -c (create and attach, needs TTY)
        echo -e "${GREEN}✓${NC} Starting agent: ${BOLD}$agent${NC}"
        echo -e "  ${DIM}Detach with Ctrl+\\${NC}"
        dtach -c "$socket" -z bash -c "cd \"$wt_dir\" && $agent_cmd" 2> "$log_file"
    else
        # No TTY available — fall back to background
        dtach -n "$socket" -z bash -c "cd \"$wt_dir\" && $agent_cmd" > "$log_file" 2>&1
        echo -e "${GREEN}✓${NC} Agent started (background): ${BOLD}$agent${NC}"
        echo -e "  Attach: ${DIM}gr attach $branch${NC}"
    fi
}

cmd_status() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo -e "${DIM}No worktrees${NC}"
        return 0
    fi

    printf "${DIM}%-24s %-10s %-10s %s${NC}\n" "BRANCH" "AGENT" "STATUS" "LAST ACTIVITY"

    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        cmd_status_single "$wt_dir"
    done
}

cmd_status_single() {
    local wt_dir="$1"
    local slug branch agent_name status_str activity

    slug="$(basename "$wt_dir")"
    branch="$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$slug")"

    # Agent name
    agent_name="${GROVE_AGENT:-}"
    if [[ -z "$agent_name" ]]; then
        agent_name="$(detect_agent_name)"
    fi
    agent_name="${agent_name:-—}"

    # Status
    if is_agent_running "$wt_dir"; then
        status_str="${GREEN}running${NC}"
    else
        status_str="${DIM}done${NC}"
    fi

    # Last activity
    activity="$(get_last_activity "$wt_dir" 2>/dev/null)" || activity=""

    # If done, try to show diff stat instead
    if ! is_agent_running "$wt_dir" && [[ -z "$activity" ]]; then
        activity=""
    fi

    # Prompt info
    local prompt_file
    prompt_file="$(grove_prompt_path "$wt_dir")"
    if [[ -n "$activity" ]]; then
        : # already have activity
    elif [[ -f "$prompt_file" ]]; then
        local saved_prompt
        saved_prompt="$(cat "$prompt_file")"
        activity="\"${saved_prompt}\""
    fi

    printf "%-24s %-10s " "$branch" "$agent_name"
    printf "%b" "$status_str"
    # Pad status column (account for color codes)
    printf "%-4s" ""
    if [[ -n "$activity" ]]; then
        echo -e " $activity"
    else
        echo
    fi
}

cmd_attach() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr attach <branch>" >&2
        exit 1
    fi

    local slug wt_dir socket
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"
    socket="$(grove_socket_path "$wt_dir")"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        echo -e "Start it first: ${DIM}gr checkout $branch${NC}" >&2
        exit 1
    fi

    if [[ ! -S "$socket" ]]; then
        echo -e "${RED}Error:${NC} No running agent for '$branch'" >&2
        echo -e "Start one: ${DIM}gr checkout $branch${NC}" >&2
        exit 1
    fi

    exec dtach -a "$socket" -z
}

cmd_log() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr log <branch>" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    local base
    base="$(cd "$wt_dir" && git merge-base HEAD main 2>/dev/null)" || {
        # Fallback: just show recent commits
        (cd "$wt_dir" && git log --oneline -20)
        return
    }

    (cd "$wt_dir" && git log --oneline "$base"..HEAD)
}

cmd_diff() {
    local branch="${1:-}"

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr diff <branch>" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} No worktree for '$branch'" >&2
        exit 1
    fi

    local base
    base="$(cd "$wt_dir" && git merge-base HEAD main 2>/dev/null)" || {
        echo -e "${RED}Error:${NC} Could not find merge base with main" >&2
        exit 1
    }

    (cd "$wt_dir" && git diff "$base"..HEAD)
}

cmd_rm() {
    local branch="${1:-}"

    if [[ "$branch" == "--all" ]]; then
        cmd_rm_all
        return
    fi

    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error:${NC} Missing branch name" >&2
        echo "Usage: gr rm <branch>" >&2
        echo "       gr rm --all" >&2
        exit 1
    fi

    local slug wt_dir
    slug="$(slugify_branch "$branch")"
    wt_dir="$GROVE_ROOT/$GROVE_WORKTREE_DIR/$slug"

    if [[ ! -d "$wt_dir" ]]; then
        echo -e "${RED}Error:${NC} Worktree not found: $slug" >&2
        exit 1
    fi

    # Safety: refuse if cwd is inside the worktree
    local real_pwd real_wt
    real_pwd="$(cd "$PWD" && pwd -P)"
    real_wt="$(cd "$wt_dir" && pwd -P 2>/dev/null || echo "$wt_dir")"
    if [[ "$real_pwd" == "$real_wt"* ]]; then
        echo -e "${RED}Error:${NC} Cannot remove worktree while inside it" >&2
        echo -e "  cd out first: ${DIM}cd $GROVE_ROOT${NC}" >&2
        exit 1
    fi

    # Kill agent if running
    if is_agent_running "$wt_dir"; then
        kill_agent "$wt_dir"
        echo -e "Agent killed"
    fi

    # Remove worktree
    git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true
    echo -e "${GREEN}✓${NC} Removed: $slug"
}

cmd_rm_all() {
    local wt_base="$GROVE_ROOT/$GROVE_WORKTREE_DIR"

    if [[ ! -d "$wt_base" ]] || [[ -z "$(ls -A "$wt_base" 2>/dev/null)" ]]; then
        echo "Nothing to remove."
        return 0
    fi

    echo -e "${BOLD}Will remove:${NC}"
    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        echo "  $(basename "$wt_dir")"
    done

    echo
    read -rp "Remove all worktrees and agents? [y/N] " confirm
    if [[ "$confirm" != [yY] ]]; then
        echo "Cancelled."
        return 0
    fi

    for wt_dir in "$wt_base"/*/; do
        [[ -d "$wt_dir" ]] || continue
        local slug
        slug="$(basename "$wt_dir")"

        kill_agent "$wt_dir"
        git -C "$GROVE_ROOT" worktree remove "$wt_dir" --force 2>/dev/null || rm -rf "$wt_dir"
    done

    git -C "$GROVE_ROOT" worktree prune 2>/dev/null || true
    echo -e "${GREEN}✓${NC} All worktrees removed"
}

# ─── Init ────────────────────────────────────────────────────────────────────

detect_project() {
    local dir="$1"
    local type="unknown" setup=""

    local pm="npm"
    if [[ -f "$dir/bun.lockb" ]] || [[ -f "$dir/bun.lock" ]]; then
        pm="bun"
    elif [[ -f "$dir/pnpm-lock.yaml" ]]; then
        pm="pnpm"
    elif [[ -f "$dir/yarn.lock" ]]; then
        pm="yarn"
    fi

    if [[ -f "$dir/Cargo.toml" ]]; then
        type="rust"
        setup="cargo build"
    elif [[ -f "$dir/go.mod" ]]; then
        type="go"
        setup="go build ./..."
    elif [[ -f "$dir/package.json" ]]; then
        type="node ($pm)"
        setup="$pm install"
    elif [[ -f "$dir/pyproject.toml" ]]; then
        if [[ -f "$dir/uv.lock" ]]; then
            type="python (uv)"
            setup="uv sync"
        else
            type="python"
            setup="pip install -e ."
        fi
    elif [[ -f "$dir/requirements.txt" ]]; then
        type="python"
        setup="pip install -r requirements.txt"
    elif [[ -f "$dir/Gemfile" ]]; then
        type="ruby"
        setup="bundle install"
    elif [[ -f "$dir/composer.json" ]]; then
        type="php"
        setup="composer install"
    fi

    echo "$type"
    echo "$setup"
}

cmd_init() {
    # ── Global config (~/.grove) ──
    if [[ ! -f "$GROVE_CONFIG" ]]; then
        local default_agent
        default_agent="$(detect_agent_name)"

        echo -e "${BOLD}Global config${NC} (~/.grove)"
        echo -e "${BOLD}Agent${NC} (coding agent to use):"
        printf "  [%s] > " "$default_agent"
        local agent_line
        if IFS= read -r agent_line; then
            if [[ -z "$agent_line" && -n "$default_agent" ]]; then
                agent_line="$default_agent"
            fi
        fi

        if [[ -n "$agent_line" ]]; then
            printf 'GROVE_AGENT="%s"\n' "$agent_line" > "$GROVE_CONFIG"
            echo -e "${GREEN}✓${NC} Created ~/.grove"
            GROVE_AGENT="$agent_line"
        else
            echo -e "${DIM}Skipped (no agent found)${NC}"
        fi

        echo
    else
        echo -e "${DIM}~/.grove already exists${NC}"
        load_grove_config
        echo
    fi

    # ── Per-repo Grovefile ──
    if ! find_grove_root; then
        echo -e "${DIM}Not in a git repo — skipping Grovefile${NC}"
        return 0
    fi

    if [[ -f "$GROVE_ROOT/Grovefile" ]]; then
        echo -e "${DIM}Grovefile already exists${NC}"
        return 0
    fi

    local project_name
    project_name="$(basename "$GROVE_ROOT")"

    local detection type default_setup
    detection="$(detect_project "$GROVE_ROOT")"
    type="$(echo "$detection" | sed -n '1p')"
    default_setup="$(echo "$detection" | sed -n '2p')"

    if [[ "$type" != "unknown" ]]; then
        echo -e "Detected: ${BOLD}${type}${NC}"
    fi

    # ── Collect setup commands ──
    local setup_cmds=()
    echo -e "${BOLD}Setup${NC} (runs once per worktree, empty line to skip):"
    printf "  [%s] > " "$default_setup"
    local line
    if IFS= read -r line; then
        if [[ -z "$line" && -n "$default_setup" ]]; then
            setup_cmds+=("$default_setup")
        elif [[ -n "$line" ]]; then
            setup_cmds+=("$line")
        fi
    fi

    echo

    # ── Generate Grovefile ──
    local grovefile=""
    grovefile+="GROVE_PROJECT=\"${project_name}\""
    grovefile+=$'\n'

    if [[ ${#setup_cmds[@]} -gt 0 ]]; then
        grovefile+=$'\n'
        grovefile+="grove_setup() {"
        grovefile+=$'\n'
        for cmd in "${setup_cmds[@]}"; do
            grovefile+="    ${cmd}"
            grovefile+=$'\n'
        done
        grovefile+="}"
        grovefile+=$'\n'
    fi

    printf '%s' "$grovefile" > "$GROVE_ROOT/Grovefile"

    echo -e "${GREEN}✓${NC} Created Grovefile"
    echo
    while IFS= read -r line; do
        echo "  $line"
    done < "$GROVE_ROOT/Grovefile"
}

cmd_completions() {
    cat <<'COMP'
# grove shell completions — add to .bashrc or .zshrc:
#   eval "$(grove completions)"   or   eval "$(gr completions)"

_grove_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case "$prev" in
        attach|rm|log|diff|checkout|co)
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                # Offer both slug names (easy to type) and branch names
                local names=""
                for d in "$wt_base"/*/; do
                    [ -d "$d" ] || continue
                    names="$names $(basename "$d")"
                    local b
                    b="$(cd "$d" && git rev-parse --abbrev-ref HEAD 2>/dev/null)" || continue
                    [[ "$b" != "$(basename "$d")" ]] && names="$names $b"
                done
                COMPREPLY=($(compgen -W "$names" -- "$cur"))
            fi
            ;;
        grove|gr)
            local subcmds="checkout status log diff rm attach init help version completions"
            local branches=""
            local wt_base
            wt_base="$(git rev-parse --show-toplevel 2>/dev/null)/.worktrees"
            if [[ -d "$wt_base" ]]; then
                branches="$(ls "$wt_base" 2>/dev/null)"
            fi
            local git_branches
            git_branches="$(git branch --format='%(refname:short)' 2>/dev/null)"
            COMPREPLY=($(compgen -W "$subcmds $branches $git_branches" -- "$cur"))
            ;;
    esac
}

if [[ -n "$ZSH_VERSION" ]]; then
    autoload -U +X bashcompinit && bashcompinit
fi
complete -F _grove_completions grove
complete -F _grove_completions gr
COMP
}

cmd_help() {
    cat <<EOF
$(echo -e "${BOLD}grove${NC}") — agent-first worktree manager (v${GROVE_VERSION})

$(echo -e "${BOLD}USAGE:${NC}")
  gr checkout <branch>             Create worktree + start agent
                                   (prompts for task, enter to skip)
  gr <branch> "prompt"            Shorthand — skip the prompt step
  gr status                       Show all worktrees, agents, activity
  gr attach <branch>              Snap into a running agent session
  gr log <branch>                 Agent's commits on this branch
  gr diff <branch>                What the agent changed vs base
  gr rm <branch>                  Kill agent + remove worktree
  gr rm --all                     Remove everything (with confirmation)

$(echo -e "${BOLD}OTHER:${NC}")
  gr init                         Set up ~/.grove + Grovefile
  gr help                         Show this help
  gr version                      Show version
  gr completions                  Output shell completions

$(echo -e "${BOLD}CONFIGURATION:${NC}")
  ~/.grove (global):
    GROVE_AGENT="claude"

  Grovefile (per-repo, optional):
    GROVE_PROJECT="myapp"
    grove_setup() { npm install; }

$(echo -e "${BOLD}DETACH:${NC}")
  Ctrl+\\  detach from a foreground agent session
EOF
}

# ─── Main Dispatch ───────────────────────────────────────────────────────────

main() {
    local cmd="${1:-}"

    case "$cmd" in
        "")
            load_grovefile
            cmd_status
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            echo "grove v${GROVE_VERSION}"
            ;;
        checkout|co)
            load_grovefile
            if [[ -z "${2:-}" ]]; then
                echo -e "${RED}Error:${NC} Missing branch name" >&2
                echo "Usage: gr checkout <branch> [\"prompt\"]" >&2
                exit 1
            fi
            cmd_checkout "${@:2}"
            ;;
        status|ls|list)
            load_grovefile
            cmd_status
            ;;
        attach)
            load_grovefile
            cmd_attach "${2:-}"
            ;;
        log)
            load_grovefile
            cmd_log "${2:-}"
            ;;
        diff)
            load_grovefile
            cmd_diff "${2:-}"
            ;;
        rm|remove)
            load_grovefile
            cmd_rm "${2:-}"
            ;;
        completions)
            cmd_completions
            ;;
        init)
            cmd_init
            ;;
        *)
            # Catch-all: treat as branch name (shorthand for checkout)
            load_grovefile
            cmd_checkout "$cmd" "${@:2}"
            ;;
    esac
}

main "$@"
